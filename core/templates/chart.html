{% extends "layouts/base.html" %}
{% load static %}

{% block header %}Chart{% endblock %}

{% block content %}
<div id="chart-container">
    <div id="chart"></div>
</div>
<script src="{% static 'js/plotly-2.36.2.min.js' %}"></script>
<script>
    var traces = [];
    const MAX_POINTS = 1000;
    const POLLING_INTERVAL = 1000; // 5 seconds

    // Initial data fetch
    fetch('/api/sensor-data/')
        .then(response => response.json())
        .then(response => {
            var rpiGroups = {};

            response.data.forEach(item => {
                if (!rpiGroups[item.rpi]) {
                    rpiGroups[item.rpi] = { x: [], y: [] };
                }
                rpiGroups[item.rpi].x.push(item.timestamp);
                rpiGroups[item.rpi].y.push(item.t);
            });

            for (var rpi in rpiGroups) {
                traces.push({
                    x: rpiGroups[rpi].x,
                    y: rpiGroups[rpi].y,
                    mode: 'lines',
                    name: rpi
                });
            }

            Plotly.newPlot('chart', traces);
        });

    function updateChart(data) {
        var update = { x: [], y: [] };
        var rpiGroups = {};

        data.forEach(item => {
            if (!rpiGroups[item.rpi]) {
                rpiGroups[item.rpi] = { x: [], y: [] };
            }
            rpiGroups[item.rpi].x.push(item.timestamp);
            rpiGroups[item.rpi].y.push(item.t);
        });

        traces.forEach((trace, i) => {
            const rpi = trace.name;
            if (rpiGroups[rpi]) {
                update.x.push(rpiGroups[rpi].x);
                update.y.push(rpiGroups[rpi].y);

                if (trace.x.length > MAX_POINTS) {
                    const excess = trace.x.length - MAX_POINTS;
                    trace.x = trace.x.slice(excess);
                    trace.y = trace.y.slice(excess);
                }
            }
        });

        if (update.x.length > 0) {
            Plotly.extendTraces('chart', update, Array.from(Array(update.x.length).keys()));
        }
    }

    // Regular polling with fetch
    setInterval(() => {
        fetch('/api/sensor-data/?recent=true')
            .then(response => response.json())
            .then(response => updateChart(response.data))
            .catch(error => console.error('Error fetching data:', error));
    }, POLLING_INTERVAL);
</script>
{% endblock %}